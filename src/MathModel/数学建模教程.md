---
title: 数学建模教程
tags: 数学建模
data: 2024-8-8
cover: https://cdn.jsdelivr.net/gh/czlifetime/img/f557269f0a7a85cb5bb24a48d1f2542d.jpeg
---



# 数学建模教程

<h1 id="VYnM1">教程</h1>
<h2 id="KYnje">数学建模题型类型</h2>
<h3 id="xl29u">预测类</h3>
> + 指通过分析已有的数据或者现象，找出其内在发展规律，然后对未来情形做出预测的过程。
> + 根据已知条件和求解目的，往往将预测类问题分为：小样本内部预测，大样本内部预测，小样本未来预测，大样本随机因素或周期特征的未来预测，大样本的未来预测。
>

**解决预测类赛题的一般步骤：**

1. 确定预测目标：
2. 收集、分析资料；
3. 选择合适的预测方法进行预测：
4. 分析评价预测方法及其结果；
5. 修正预测结果；
6. 给出预测结果

**算法选择：**

:::info
**中短期预测：**

1. 灰色预测
2. 回归分析
3. 时间序列预测
4. 微分方程预测

**长期预测**

1. 神经网络预测
2. Logistics预测
3. 微分方程

:::

<h3 id="u7Kxm">评价类</h3>
> + 指按照一定的标准对事物的发展或者现状进行划分的过程在数学建模中题点可体现在对生态环境，社会建设，方案策略等进行评价。评价类赛题往往没有明确的指标体系和评价标准，往往是需要查阅各类资料进行构建的，因此评价类赛题也没有明确的答案
> + 赛题分析：解决评价类赛题的关键是指标体系的构建，构建完评价体系后在选择合适的评价方法即可，体系建立应秉承全面，准确，独立的三要素
>

**解决评价类赛题的一般步骤：**

1. 明确评价目的：
2. 确定被评价对象；
3. 建立评价指标体系
4. 确定各指标相对应的权重系数；
5. 选择或构造综合评价模型；
6. 计算各系统的综合评价值
7. 给出综合评价结果，

:::info
**算法：**

**主观评价：**

1. 层次分析法
2. 模糊综合评价法
3. 灰色关联分析法

**客观评价：**

1. 主成分分析法
2. 因子分析法
3. TOPSIS分析法
4. 神经网络分析法

:::

<h3 id="nC7CE">机理分析法</h3>
> + 所机理分析是根据对现实对象特性的认识，分析其因果关系，找出反映内部机理的规律。在求解机理分析类问题时首先需要探寻与问题相关的物理，化学，经济等相关的知识，然后通过对已知数据或现象的分析对事物的内在规律做出必要的假设，最后通过构建合适的方程或关系式对其内在规律进行数值表达
> + 赛题分析：机理分析立足于建立事物内部的规律，相对于其他类型的赛题均有章可循，机理分析类赛题往往需要结合众多关联知识才可以进行求解，如空气动力学，流体力学，热力学等
>

<h3 id="zXxrS">优化类</h3>
> + 指在现有现有条件固定的情况下，如何使目标效果达到最佳。如在一座城市公交车公司拥有的公交车数量是固定的，问如何安排线路能够使盈利达到最高。优化类问题往往需要分析三个关键因素：目标函数，决策变量和约束条件，三者往往缺一不可。
> + 赛题分析：解决优化类赛题必须知道优化的目的，约束的条件和所求解的关键变量，需要有较强的编程能力和赛题分析挖掘能力
>

**解决预测类赛题的一般步骤：**

1. 确定优化目标；
2. 确定决策变量
3. 构建目标函数；
4. 根据已知条件构建约束条件；
5. 选择合适的方法求解目标函数；
6. 给出优化结果

:::info
**算法**

**根据目标函数及约束条件类型分类**

1. 线性规划
2. 非线性规划
3. 二次规划

**控制变量类型分类**

1. 整数规划
2. 混合整数规划
3. 0-1规划

**其他分类方法**

1. 单目标规划与多目标规划模型
2. 动态规划与静态规划
3. 随机规划与确定规划

**智能优化类型**

1. 粒子群算法
2. 遗传算法
3. 模拟退火算法

:::

<h2 id="skmTo">算法</h2>
<h3 id="Nw2YS">线性规划问题</h3>
+ 示例：

:::color1
<font style="color:rgb(44, 44, 54);">目标函数 MAX：Z = 2x₁ + 3x₂ - 5x₃</font>

:::



:::color3
约束条件：

1. <font style="color:rgb(44, 44, 54);">x₁ + x₂ + x₃ = 7 （等于约束）</font>
2. <font style="color:rgb(44, 44, 54);">2x₁ - 5x₂ + x₃ >= 10 （大于等于约束）</font>
3. <font style="color:rgb(44, 44, 54);">x₁ + 3x₂ + x₃ <= 12 （小于等于约束）</font>
4. <font style="color:rgb(44, 44, 54);">x₁, x₂, x₃ >= 0 （非负约束）</font>

:::

+ 代码：

```python
from scipy.optimize import linprog
"""
    已知等式Z=2x_{1}+3x_{2}-5x_{3}，
    约束条件为
    x_{1}+x_{2}+x_{3}=7;
    2x_{1}-5x_{2}+x_{3}>=10;
    x_{1}+3x_{2}+x_{3}≤12;
    x_{1},x_{2},x_{3} ≥0，
    求出当Z最大时，x_{1},x_{2},x_{3}的值
"""
# 目标函数的系数
c = [-2, -3, 5]  # 注意，我们取的是-Z的系数，因为linprog默认是求最小值问题

# 约束条件的系数矩阵（A_ub是不等式约束，A_eq是等式约束）
A_ub = [[-2, 5, -1], [1, 3, 1]]  # 大于等于和小于等于的约束
b_ub = [-10, 12]  # 对应的大于等于和小于等于约束的右侧值

# 等式约束
A_eq = [[1, 1, 1]]
b_eq = [7]

# 变量的边界（非负约束）
bounds = [(0, None), (0, None), (0, None)]

# 解决线性规划问题
result = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds)

print(result.x, result.fun * -1)  # 输出解和最大化后的Z值

```

linprog函数：

```python
scipy.optimize.linprog(c, A_ub=None, b_ub=None, A_eq=None, b_eq=None, bounds=None, method='highs', options=None)
```

<details class="lake-collapse"><summary id="uf5189bfa"><span class="ne-text" style="color: rgb(26, 32, 41)">参数说明</span></summary><ul class="ne-ul"><li id="ud45a5057" data-lake-index-type="0" style="text-align: left"><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">c</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">: array_like</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><span class="ne-text" style="color: rgb(26, 32, 41)">目标函数的系数，用于构建目标函数</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">c @ x</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">，其中</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">@</span></code><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><span class="ne-text" style="color: rgb(26, 32, 41)">表示矩阵乘法。如果目标是最大化目标函数，可以将</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">c</span></code><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><span class="ne-text" style="color: rgb(26, 32, 41)">的元素取反。</span></li><li id="ube3c56e4" data-lake-index-type="0" style="text-align: left"><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">A_ub</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">: array_like, optional</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><span class="ne-text" style="color: rgb(26, 32, 41)">不等式约束的系数矩阵。每一行对应一个不等式约束</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">A_ub @ x &lt;= b_ub</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">。</span></li><li id="u7328c04b" data-lake-index-type="0" style="text-align: left"><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">b_ub</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">: array_like, optional</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><span class="ne-text" style="color: rgb(26, 32, 41)">不等式约束的右侧值。</span></li><li id="u8d328ef3" data-lake-index-type="0" style="text-align: left"><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">A_eq</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">: array_like, optional</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><span class="ne-text" style="color: rgb(26, 32, 41)">等式约束的系数矩阵。每一行对应一个等式约束</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">A_eq @ x == b_eq</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">。</span></li><li id="ud2c87238" data-lake-index-type="0" style="text-align: left"><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">b_eq</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">: array_like, optional</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><span class="ne-text" style="color: rgb(26, 32, 41)">等式约束的右侧值。</span></li><li id="ud4471c6a" data-lake-index-type="0" style="text-align: left"><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">bounds</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">: sequence, optional</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><span class="ne-text" style="color: rgb(26, 32, 41)">变量的界限，格式为</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">(min, max)</span></code><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><span class="ne-text" style="color: rgb(26, 32, 41)">对，可以为每个变量指定不同的界限。如果没有指定，默认为</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">(0, None)</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">，即非负约束。</span></li><li id="u29e05cb0" data-lake-index-type="0" style="text-align: left"><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">method</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">: str, optional 指定求解器的方法。默认为 </span><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41)">highs</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">，这是 SciPy 1.5.0 之后推荐的方法。其他可选方法包括 ‘highs-ds’、‘highs-ipm’、‘interior-point’、‘revised simplex’ 等。</span></li><li id="u69a27089" data-lake-index-type="0" style="text-align: left"><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">options</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">: dict, optional 传递给求解器的额外选项。</span></li></ul></details>
<details class="lake-collapse"><summary id="uf82a1ff6"><span class="ne-text" style="font-size: 16px">返回值</span></summary><p id="u99c5e48f" class="ne-p" style="text-align: left"><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">linprog</span></code><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><span class="ne-text" style="color: rgb(26, 32, 41)">函数返回一个优化结果对象，其中包含以下属性：</span></p><ul class="ne-ul"><li id="u35cf4fe5" data-lake-index-type="0" style="text-align: left"><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">x</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">: array</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><span class="ne-text" style="color: rgb(26, 32, 41)">最优解。</span></li><li id="ue33b16ee" data-lake-index-type="0" style="text-align: left"><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">fun</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">: float</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><span class="ne-text" style="color: rgb(26, 32, 41)">最优目标函数值。</span></li><li id="u7f298e8f" data-lake-index-type="0" style="text-align: left"><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">slack</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">: array</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><span class="ne-text" style="color: rgb(26, 32, 41)">不等式约束的松弛变量。</span></li><li id="ucd288b3f" data-lake-index-type="0" style="text-align: left"><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">con</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">: array</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><span class="ne-text" style="color: rgb(26, 32, 41)">等式约束的乘子。</span></li><li id="ue8afa5de" data-lake-index-type="0" style="text-align: left"><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">success</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">: bool</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><span class="ne-text" style="color: rgb(26, 32, 41)">表示是否成功找到最优解。</span></li><li id="ua44dd161" data-lake-index-type="0" style="text-align: left"><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">status</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">: int</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><span class="ne-text" style="color: rgb(26, 32, 41)">表示求解器的状态。</span></li><li id="u6afe7fcd" data-lake-index-type="0" style="text-align: left"><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">message</span></code><span class="ne-text" style="color: rgb(26, 32, 41)">: str 描述求解器状态的字符串。</span></li></ul></details>
<details class="lake-collapse"><summary id="u2b46acd9"><span class="ne-text" style="font-size: 16px">注意事项</span></summary><ul class="ne-ul"><li id="ua7b6e3e0" data-lake-index-type="0" style="text-align: left"><code class="ne-code"><span class="ne-text" style="color: #DF2A3F; font-size: 13px">linprog</span></code><span class="ne-text" style="color: #DF2A3F"> 默认解决的是最小化问题，如果需要最大化目标函数，应将目标函数系数取反。</span></li><li id="u212a27b8" data-lake-index-type="0" style="text-align: left"><span class="ne-text" style="color: #DF2A3F">默认是</span><span class="ne-text" style="color: #DF2A3F; background-color: #FBDE28">小于等于</span><span class="ne-text" style="color: #DF2A3F">，如果不等式</span><span class="ne-text" style="color: #DF2A3F; background-color: #FBDE28">出现大于等于</span><span class="ne-text" style="color: #DF2A3F">，记得不等式</span><span class="ne-text" style="color: #DF2A3F; background-color: #FBDE28">两边</span><span class="ne-text" style="color: #DF2A3F">要</span><span class="ne-text" style="color: #DF2A3F; background-color: #FBDE28">同时乘以-1</span></li><li id="u7a5e1bf2" data-lake-index-type="0" style="text-align: left"><span class="ne-text" style="color: rgb(26, 32, 41)">确保约束条件是线性的。</span></li><li id="u46a360e5" data-lake-index-type="0" style="text-align: left"><span class="ne-text" style="color: rgb(26, 32, 41)">检查</span><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">result.success</span></code><span class="ne-text" style="color: rgb(26, 32, 41)"> </span><span class="ne-text" style="color: rgb(26, 32, 41)">以确认是否找到了有效解。</span></li><li id="u76f3efa1" data-lake-index-type="0" style="text-align: left"><span class="ne-text" style="color: rgb(26, 32, 41)">如果问题规模较大或约束条件复杂，可能需要调整 </span><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">method</span></code><span class="ne-text" style="color: rgb(26, 32, 41)"> 和 </span><code class="ne-code"><span class="ne-text" style="color: rgb(26, 32, 41); font-size: 13px">options</span></code><span class="ne-text" style="color: rgb(26, 32, 41)"> 参数以获得更好的性能。</span></li></ul></details>
<h3 id="rTFeE">整数规划</h3>
> 数学规划中的变量（部分或全部）限制为整数时，称为整数规划。若在线性规划模型中，变量限制为整数，则称为整数线性规划。目前所流行的求解整数规划的方法，往往只适用于整数线性规划。目前还没有一种方法能有效地求解一切整数规划。
>

**整数规划的特点**

1. 原线性规划有最优解，当自变量限制为整数后，其整数规划解出现下述情况

(1)原线性规划最优解全是整数，则整数规划最优解与线性规划最优解一致。

(2）整数规划无可行解。

(3）有可行解（当然就存在最优解），但最优解值变差。

2. 整数规划最优解不能按照实数最优解简单取整而获得。



<h2 id="jtCxY">Topsis方法</h2>
评价方法大体上可分为两类，其主要区别在确定权重的方法上。一类是**主观赋权法**，多数采取综合咨询评分确定权重，如综合指数法、模糊综合评判法、层次分析法、功效系数法等。另一类是**客观赋权**，根据各指标间相关关系或各指标值变异程度来确定权数，如主成分分析法、因子分析法、理想解法去（也称TOPSIS 法）等。

> 目前已有许多解决多属性决策的排序法，如理想点法、简单线性加权法、加权平方和法、主成分分析法、功效系数法、可能满意度法、交叉增援矩阵法等。本节介绍多属性决策问题的理想解法，理想解法亦称为TOPSIS法，是一种有效的多指标评价方法。这种方法通过构造评价问题的正理想解和负理想解，即各指标的最优解和最劣解，通过计算每个方案到理想方案的相对贴近度，即靠近正理想解和远离负理想解的程度，来对方案进行排序，从而选出最优方案。
>

**方法和原理**

设多属性决策方案集为$ D={d_{1},d_{2},...,d_{m}} $，衡量方案优劣的属性变量为$ x_{1},...x_{n} $这时方案集D中的每个方案$ d_{i}(i=1,... m) $的n个属性值构成的向量是$ a_{i1},...,a_{in} $，它作为n维空间中的一个点，能唯一地表征方案$ d_{i} $。

正理想解$ C* $是一个方案集D中并不存在的虚拟的最佳方案，它的每个属性值都是决策矩阵中该属性的最好值；而负理想解$ C^{0} $则是虚拟的最差方案，它的每个属性值都是决策矩阵中该属性的最差值。在n维空间中，将方案集D中的各备选方案$ d_{i} $与正理想解$ C^{*} $和负理想解$ C^{0} $的距离进行比较，既靠近正理想解又远离负理想解的方案就是方案集D中的最佳方案；并可以据此排定方案集D中各备选方案的优先序。

**算法步骤**

TOPSIS法的具体算法如下：

1. 用向量规划化的方法求得规范决策矩阵

设多属性决策问题的决策矩阵$ A=(a_{ij})_{m×n} $，规范化决策矩阵$ B=(b_{ij})_{m×n} $，其中

$ b_{ij}=\frac{a_{ij}}{\sqrt{\sum_{i=1}^{n}a_{ij}^{2}}},i=1,2,...,m,j=1,2,...,n $

2. 构成加权规范阵$ C=(c_{ij})_{m×n} $

设由决策热给定各属性的权重向量为$ w=[w_{1},w_{2},w_{3},...,w_{n}]^{T} $，则

$ c_{ij} = w_{j·b_{ij}},i=1,2,...,m,j=1,2,...,n $

3. 确定正理想解$ C^{*} $和负理想解$ C^{0} $

设正理想解$ C^{*} $的第j个属性值为$ c_{j}^{*} $，负理想解$ C^{0} $第j个属性值为$ c^{0}_{j} $，则 ![](https://cdn.nlark.com/yuque/0/2024/png/36047305/1721556149436-a91aa430-ab6f-410e-a546-ea2569a2f9e8.png)

4. 计算各方案到正理想解与负理想解的距离

![](https://cdn.nlark.com/yuque/0/2024/png/36047305/1721556505627-dafc79d0-aed4-4210-b5dd-d973b629a80b.png)

5. 计算各方案的排队指标值（综合评价指数）

![](https://cdn.nlark.com/yuque/0/2024/png/36047305/1721556567997-d4887c53-1140-4f38-b455-040d6838788b.png)

6. 按$ f_{i}^{*} $由大到小排序方案的优劣次序

